{"name":"py_tsg","tagline":"A Python wrapper around the Tasmanian sparse grid library","body":"Project page: http://rncarpio.github.com/py_tsg\r\n\r\n### What is `py_tsg`?\r\n`py_tsg` is a Python wrapper around the [Tasmanian Sparse Grid Library (TSG)](http://tasmanian.ornl.gov/) for high-dimensional interpolation and integration using sparse grids (e.g. Smolyak grids).  TSG is written in C++ and supports a variety of polynomial basis functions, anisotropic weights, and adaptive local refinement.\r\nFor more information on TSG, visit http://tasmanian.ornl.gov/ or look at the [manual](http://tasmanian.ornl.gov/manuals.html).\r\n\r\nThis version is based on [TSG v1.0, released August 2013](http://tasmanian.ornl.gov/downloads.html). The code has been slightly modified to compile under Windows. The Python wrapper requires [Boost.Python](http://www.boost.org/doc/libs/1_55_0/libs/python/doc/index.html) and [PyUblas](http://mathema.tician.de/software/pyublas/) to be installed.\r\n\r\n### Installation\r\nAssuming you have [Boost.Python](http://www.boost.org/doc/libs/1_55_0/libs/python/doc/index.html) and [PyUblas](http://mathema.tician.de/software/pyublas/) already installed, download the files and type `make all`. The makefile should handle both Linux and Windows (tested with MSVC 2010). A shared library `libtasmaniansparsegrid.so` or its Windows equivalent should be produced; set your paths to detect this. Another shared library `_py_tsg.so` or `_py_tsg.pyd` should be produced; from Python, you can type `import _py_tsg`.\r\n\r\n### Interface\r\nThe interface is a straightforward translation of the C++ API. See the [TSG manual](http://tasmanian.ornl.gov/manuals.html) and the file `tsg_python.cpp` for details.\r\n\r\n### Examples\r\n\r\nThe following examples are copied from the `example.cpp` file in the TSG distribution.\r\nExample 1: \r\n```python\r\n# EXAMPLE 1:\r\n# make a classical Smolyak grid using Clenshaw-Curtis quadrature\r\n# integrate the function f(x,y) = exp( -x^2 ) * cos( y )\r\n# the exact answer is: 2.513723354063905e+00\r\n\r\nimport scipy, scipy.integrate, itertools\r\nimport pyublas\r\nimport _py_tsg as tsg\r\n\r\ngrid = tsg.TSG()\r\ndef fn1(x):\t\treturn scipy.exp(-x[0]*x[0])*scipy.cos(x[1])\r\ndimension = 2\r\noutputs = 0\r\nlevel = 7\r\ngrid.make_global_grid( dimension, outputs, level, tsg.TypeDepth.type_level, tsg.TypeOneDRule.rule_clenshawcurtis, scipy.array([], dtype=int), 0, 0 )\r\npoints = grid.get_points()\r\nweights = grid.get_weights()\r\nsum = scipy.sum( [w*fn1(x) for (x,w) in zip(points, weights)] )\r\nprint(\"\\nExample 1\")\r\nprint(\"grid has: %d points\" % grid.get_num_points())\r\nprint(\"integral is: %.17f\" % sum)\r\nprint(\"error: %.17f\" % scipy.fabs( sum - 2.513723354063905e+00 ))\r\n```\r\nproduces:\r\n```\r\nExample 1\r\ngrid has: 321 points\r\nintegral is: 2.51372335405531810\r\nerror: 0.00000000000858691\r\n```\r\n\r\nExample 2:\r\n```python\r\n# make a Clenshaw-Curtis rule that interpolates exactly polynomials of order up to 10\r\n# integrate the function f(x,y) = exp( -x^2 ) * cos( y )\r\n# exact values is: 6.990131267703512e-01\t\r\n\r\nimport scipy, scipy.integrate, itertools\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\nimport matplotlib.pyplot as plt\r\n\r\nimport pyublas\r\nimport _py_tsg as tsg\r\n\r\ndef apply_fn_to_grid(gridList, fn):\r\n\txy_list = list(itertools.product(*gridList))\r\n\txlists = []\t\r\n\t[xlists.append( [xy[i] for xy in xy_list] ) for i in range(len(gridList))]\r\n\tf_list = [fn(xy) for xy in xy_list]\r\n\treturn (xlists, f_list)\r\n\r\ndef plot_gridpoints_2(grid):\r\n\tassert(grid.get_num_dimensions() == 2)\r\n\tpoints = grid.get_points()\r\n\tfig = plt.figure()\r\n\tplt.scatter(points[:,0], points[:,1], s=3)\r\n\tprint(\"%d gridpoints\" % len(points))\r\n\r\ndef scatter_grid_2(grid, n_gridpoints=20):\r\n\tassert(grid.get_num_dimensions() == 2)\r\n\t(low, high) = grid.get_transform_AB()\t\r\n\tgrid1 = scipy.linspace(low[0], high[0], n_gridpoints)\r\n\tgrid2 = scipy.linspace(low[1], high[1], n_gridpoints)\r\n\t(xlists, f_list) = apply_fn_to_grid([grid1, grid2], lambda x: grid.evaluate(scipy.array(x)))\r\n\tfig = plt.figure()\r\n\tax = Axes3D(fig)\t\r\n\tax.scatter3D(xlists[0], xlists[1], f_list, s=3)\t\r\n\treturn ax\r\n\r\ngrid = tsg.TSG()\r\ndef fn1(x):\t\treturn scipy.exp(-x[0]*x[0])*scipy.cos(x[1])\r\ndimension = 2\r\noutputs = 1\r\nprecision = 10\r\ngrid.make_global_grid( dimension, outputs, precision, tsg.TypeDepth.type_basis, tsg.TypeOneDRule.rule_clenshawcurtis, scipy.array([], dtype=int), 0, 0 )\r\npoints = grid.get_needed_points()\r\nvalues = fn1(points.T)\r\ngrid.load_needed_points(values)\r\nplot_gridpoints_2(grid)\r\nscatter_grid_2(grid, 50)\r\n```\r\nproduces\r\n![](https://raw.github.com/rncarpio/py_tsg/master/example1.png)\r\n![](https://raw.github.com/rncarpio/py_tsg/master/example2.png)\r\n\t\r\n### License: GPLv3\r\n\r\n`py_tsg` is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\t\r\n","google":"UA-27074418-2","note":"Don't delete this file! It's used internally to help with page regeneration."}